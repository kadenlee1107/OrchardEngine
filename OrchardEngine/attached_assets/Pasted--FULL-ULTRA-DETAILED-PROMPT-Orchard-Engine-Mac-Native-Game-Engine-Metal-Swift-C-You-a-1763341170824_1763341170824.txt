‚≠ê FULL ULTRA-DETAILED PROMPT: ‚ÄúOrchard Engine‚Äù ‚Äî Mac-Native Game Engine (Metal + Swift + C++)

You are to generate the full source code, architecture, and project structure for a professional-grade macOS-native game engine called ‚ÄúOrchard Engine.‚Äù
This engine must be high-quality, modular, and good enough to be sold commercially.
No AI systems. No external game engines. Everything must be original.

‚∏ª

üçé üìå Core Requirements

Build a real game engine, not a demo. It must include:

1. Native macOS + Apple Ecosystem Integration
	‚Ä¢	Built specifically for macOS ARM64 (M1‚ÄìM4)
	‚Ä¢	Zero Rosetta
	‚Ä¢	Full support for:
	‚Ä¢	Metal 3 rendering
	‚Ä¢	MetalFX Upscaling
	‚Ä¢	Mesh shaders (object shaders)
	‚Ä¢	Tile-based deferred+forward renderer
	‚Ä¢	Ray tracing (Metal Acceleration Structures)
	‚Ä¢	ProMotion adaptive refresh
	‚Ä¢	HDR / EDR output for XDR displays
	‚Ä¢	Editor uses SwiftUI + AppKit

2. Dual-Scripting Runtime
	‚Ä¢	Swift for high-level gameplay scripting
	‚Ä¢	C++17 (ARM64 optimized) for engine systems
	‚Ä¢	Swift ‚Üî C++ bridging for components, ECS, and resource APIs
	‚Ä¢	Hot-reload support via Swift Playgrounds + LLDB

3. ECS System

A clean, optimized Entity Component System with:
	‚Ä¢	Archetype-based storage
	‚Ä¢	Burst-like SIMD acceleration using ARM NEON
	‚Ä¢	Component hot-reload
	‚Ä¢	Event bus system
	‚Ä¢	Scene graph integration with ECS transform system

4. Physics Engine

Custom physics, not Bullet/PhysX:
	‚Ä¢	Broadphase: SAP or BVH
	‚Ä¢	Narrowphase: GJK + EPA
	‚Ä¢	Rigidbody & CharacterController
	‚Ä¢	Constraints, joints
	‚Ä¢	Trigger volumes
	‚Ä¢	Softbody option
	‚Ä¢	Physics timestep decoupled from render

5. Audio System

Using Apple CoreAudio:
	‚Ä¢	Ultra low latency audio mixer
	‚Ä¢	Spatial Audio support
	‚Ä¢	Convolution reverb
	‚Ä¢	AudioUnits integration
	‚Ä¢	Compressed/uncompressed sound banks
	‚Ä¢	Streaming audio system (for music)

6. Orchard Editor

Full game editor app built with SwiftUI:
	‚Ä¢	Scene Hierarchy
	‚Ä¢	Inspector panel
	‚Ä¢	Transform gizmos
	‚Ä¢	Material graph editor
	‚Ä¢	Shader graph (Metal Shading Language)
	‚Ä¢	Animation timeline
	‚Ä¢	Prefab system
	‚Ä¢	Drag/drop .USD, .FBX, .OBJ, .PNG, .EXR, .WAV
	‚Ä¢	Live preview via MTKView
	‚Ä¢	Multiple tabs / windows
	‚Ä¢	Undo/redo stack
	‚Ä¢	Build/export panel for macOS, iOS, iPadOS, visionOS

7. Renderer

A modern Metal renderer featuring:
	‚Ä¢	PBR pipeline (GGX, Smith masking/shadowing)
	‚Ä¢	HDR ‚Üí tone mapping
	‚Ä¢	Cascaded shadow maps
	‚Ä¢	SSAO (optional)
	‚Ä¢	SSR (optional)
	‚Ä¢	Volumetric fog
	‚Ä¢	GPU-driven occlusion culling
	‚Ä¢	GPU-driven indirect draws
	‚Ä¢	Clustered/Forward+ lighting
	‚Ä¢	Light probes + reflection probes
	‚Ä¢	Ray-traced shadows/reflections optional
	‚Ä¢	MetalFX upscale pipeline

The renderer must be written in C++ with .metal shader files.

8. File System + Assets
	‚Ä¢	Custom package format ‚Äú.orchardpkg‚Äù
	‚Ä¢	Asset database with UUID tracking
	‚Ä¢	Importers for:
	‚Ä¢	FBX
	‚Ä¢	OBJ
	‚Ä¢	USD
	‚Ä¢	PNG/JPG
	‚Ä¢	EXR
	‚Ä¢	WAV/MP3/FLAC
	‚Ä¢	Shader compilation pipeline
	‚Ä¢	Material system with graph ‚Üí code generation
	‚Ä¢	Streaming textures + mipmap generation

9. Build Targets
	‚Ä¢	macOS (primary)
	‚Ä¢	iOS
	‚Ä¢	iPadOS
	‚Ä¢	tvOS
	‚Ä¢	visionOS
	‚Ä¢	WebGPU export optional
	‚Ä¢	Xcode project generation

10. Example Game Template

Engine must ship with:
	‚Ä¢	First-person controller
	‚Ä¢	Third-person controller
	‚Ä¢	Example materials
	‚Ä¢	Example shaders
	‚Ä¢	Physics test scene
	‚Ä¢	Lighting demo scene
	‚Ä¢	Audio mixing demo

‚∏ª

üìÅ üìå Folder Structure to Generate

Generate this exact (or improved) folder structure:

OrchardEngine/
    Engine/
        Core/
        ECS/
        Math/
        Rendering/
            Metal/
                Shaders/
                RenderGraph/
        Physics/
        Audio/
        Resources/
        Platform/
            macOS/
            iOS/
        Scripting/
            SwiftBindings/
            CPPRuntime/
        Utils/
    Editor/
        App/
        Panels/
        SwiftUI/
        Icons/
        Serialization/
        SceneView/
        Builds/
    Samples/
        FirstPersonDemo/
        ThirdPersonDemo/
        PhysicsPlayground/
    Tools/
        ShaderCompiler/
        AssetPipeline/
    Documentation/
        Architecture/
        API/
        Scripting/
        Rendering/

üìå Deliverables You Must Generate

The AI generator must output:

‚úî Full source code

As complete as possible for MVP engine.

‚úî All major classes/interfaces

With definitions, skeletons, and detailed comments.

‚úî Full rendering pipeline implementation

Including Metal shaders, passes, buffers, resource management, etc.

‚úî Orchard Editor code

SwiftUI + MetalKit + scene manipulation tools.

‚úî ECS implementation

Archetypes, chunk allocation, fast iteration.

‚úî Physics engine implementation

Broadphase, narrowphase, constraints, solver.

‚úî Swift + C++ scripting bridges

‚úî Documentation

Markdown files explaining:
	‚Ä¢	Engine internals
	‚Ä¢	How to write scripts
	‚Ä¢	How the renderer works
	‚Ä¢	How the editor loads scenes
	‚Ä¢	Build + compile instructions

‚úî A complete MVP that can compile on macOS

‚∏ª

üìå Coding Guidelines
	‚Ä¢	No external game engine dependencies
	‚Ä¢	No AI libraries
	‚Ä¢	No cloud/online components
	‚Ä¢	No placeholder pseudo-code ‚Äî write real code
	‚Ä¢	Use Metal best practices
	‚Ä¢	Use C++17 with ARM64 optimizations
	‚Ä¢	Use Swift 5.9+
	‚Ä¢	Use modular, clean architecture
	‚Ä¢	Everything must be well-commented
	‚Ä¢	Focus on performance and memory layout

‚∏ª

üìå Final Instruction

Begin by generating the ENTIRE engine step by step.
Start with architecture ‚Üí file tree ‚Üí core classes ‚Üí rendering ‚Üí editor ‚Üí physics ‚Üí audio ‚Üí samples ‚Üí docs.
Do not skip anything.
Write production-quality code and explanations.